
stringliteral(name, str, size) ::= "<name> = private unnamed_addr constant [<size> x i8] c\"<str>\"<\n>"

functiondecl(name, returntype, isglobal, formals, instructions) ::= <<
define <returntype> <if(isglobal)>@<endif><name>(<formals; separator=", ">) {
  <instructions; separator="\n"> 
}<\n>
>>

externfunctiondecl(name, returntype, formals) ::= <<
declare <returntype> @<name>(<formals; separator=", ">)<\n>
>>

getpointer(result, type, obj, indices) ::= <<
<result> = getelementptr <type> <obj>, <indices; separator=", ">
>>

extractvalue(result, type, obj, indices) ::= <<
<result> = extractvalue <type> <obj>, <indices; separator=", ">
>>

label(name) ::= "<name>:"
branch(condition, positive, negitive) ::= "br i1 <condition>, label <positive>, label <negitive>"
intcompare(result, operation, type, left, right) ::= "<result> = icmp <operation> <type> <left>, <right>"
equalOperator() ::= "eq"
notEqualOperator() ::= "ne"
greaterThanOperator() ::= "sgt"
lessThanOperator() ::= "slt"
greaterThanEqualOperator() ::= "sge"
lessThanEqualOperator() ::= "sle"

int32type() ::= "i32"
localid(name) ::= "%<name>"
globalid(name) ::= "@<name>"
intliteral(value) ::= "<value>"

allocvar(result, type, num) ::= "<result> = alloca <type><if(num)>, i32 <num><endif>"
load(src, dest, type) ::= "<dest> = load <type> <src>"
store(src, dest, type) ::= "store <type> <src>, <type>* <dest>"
bitcast(src, dest, srctype, desttype) ::= "<dest> = bitcast <srctype> <src> to <desttype>"
return(result, type) ::= "ret <type> <result>"
add(result, left, right, type) ::= "<result> = add <type> <left>, <right>"
multiply(result, left, right, type) ::= "<result> = mul <type> <left>, <right>"
subtract(result, left, right, type) ::= "<result> = sub <type> <left>, <right>"
divide(result, left, right, type) ::= "<result> = sdiv <type> <left>, <right>"
bitand(result, left, right, type) ::= "<result> = and <type> <left>, <right>"
bitor(result, left, right, type) ::= "<result> = or <type> <left>, <right>"
bitxor(result, left, right, type) ::= "<result> = xor <type> <left>, <right>"
call(result, name, type, args) ::= <<
<if(result)><result> = <endif>call <type> <name>(<args; separator=", ">)
>>
select(result, selector, left, right, type) ::= "<result> = select i1 <selector>, <type> <left>, <type> <right>"
phi(result, args, type) ::= <<
<result> = phi <type> <args; separator=", ">
>>